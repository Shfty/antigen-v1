TODO: Thread safety for Store, ECS
      ECS tick runs on its own 'game thread', winit event loop on the main (i.e. render) thread
      Need to be able to pass Arc<EntityComponentSystem> between threads
            Should this be Arc<ComponentStore> instead? Clone from inside ECS before game thread takes ownership of it
      winit event loop takes a reference, uses to query windows, renderers, passes, etc
            Raises some questions re. whether the winit event loop can be classed as a system
                  Sort of, but not one that gets invoked by the ECS
                  Reads from the ECS, then invokes render passes / bundles
                  Writing to the data buffers used by these passes / bundles is done on the game thread
                        In some cases, writes are invoked by the render thread - need to account for this (ideally should be automatic via Store thread safety)

Threading architecture
      Main thread
            Spawns ECS thread, runs event loop
                  i.e. winit, curses, etc
                        Need to formalize curses event loop
                        Important to consider the need for multiple event loops
                              i.e. Being able to run curses, winit and cpal loops at the same time
                                    winit needs the main thread for cross-platform compatibility
                                    curses should in theory be able to run outside the main thread
                                          Need to check - if not, will end up being naturally mutually exclusive to winit
                                    cpal is able to run on its own thread with no issue
                                          This may be better handled inside a system
                                                Could be better still to have each domain-specific system (ex. OPL2) run its own cpal thread if allowed
                                                      Better encapsulation, offload mixing to OS
      ECS thread
            Runs systems in parallel blocks segmented by data dependency (probably via rayon's par_iter)
      System job threads
            Perform R/W on ECS, should be free to invoke their own multithreading (via rayon, std::thread::spawn, etc)

      In theory, game thread performance should be limited by the summed run-time of the slowest system in each parallel block
      Render thread should draw as often as the API is capable of, render passes should interpolate data where appropriate

Antigen
      Does
            Polymorphic data storage and querying
            Automate multi-threaded execution of program logic
            Provide a set of pre-built systems for existing use-cases
            Provide debugging and profiling tools for iteration, maintenance and optimization
      Does Not
            Impose overhead via monolithic abstrations such as gameplay, physics or rendering
            Enforce usage of any pre-built systems

Framework Concept
      Other engines have their own frameworks for various things like rendering, collision, physics, network, etc
      This often proves to be monolithic, rigid, and unfxiable, resulting in workarounds and development friction
      Solution:
            Frameworks should be modular; smaller, more specific, and interchangeable
            Where other engines allow you to pick backends as a setting, Antigen should act as a composition of them
            Backends should be represented by crates
            Ex:
                  Dragonfly
                  =========
                  Antigenesis
                        Antigen
                        Antigen-Winit
                        Antigen-WGPU
                              Antigen-Buffered-Renderer
                                    Antigen-Integer-Scale
                              Antigen-Forward-Renderer
                              Antigen-Sprite-Rendering
                              Antigen-UI
                        Antigen-CPAL
                              Antigen-OPL2
                              Antigen-Sega-PSG
                              Antigen-Sequencer
                        Antigen-GILRS
                              Antigen-Gamepad
                  Dragonfly-Game

                  - Dragonfly is the top-level crate
                        - Represents a prospective Antigen game in a Mega Drive style
                  - Antigen provides the ECS core
                  - Antigenesis provides a Mega Drive-like 'fantasy console'
                        - Abstractions for input, rendering, audio (physics?)
                              - Powered by other antigen integration crates
                              - Embody fantasy console limitations
                                    - Should provide a way to get around them if needed
                  - Dragonfly-Game provides the game logic, uses Antigenesis as an API
                        


TODO: Refactor ComponentTrait casting using downcast-rs

TODO: List restructure
      Tidy methods, refactor shared code (ex. height calculation, string preparation) into functions
      List iteration currently reads everything, when it should only take what's needed
      Proper clipping for hover/selection entities

      Refactor list item layout logic into its own component / system setup
            Currently uses a position + size based layout strategy
                  Controls are tightly packed linearly based on their size
            Anchors / margins based layout is another case worth considering
                  Should this be handled as a distinct system, or an optional element?
      
      Minus input and layout, the list's job is to maintain a set of child UI controls based on some source data

TODO: Finish builder refactor
      Replace any remaining Assembler references with Builder
      Sweep over debug scene and polish entity creation code - focus on component builders
      Settle on a naming convention for antigen - currently 'assemblage' is just a catch-all used to refer to entity/component builders

TODO: Rendering refactor
      Problem: Most renderer / framebuffer combinations aren't data-compatible
            Hardware framebuffers can't be written by a software renderer, and vice-versa
            Renderer may be too generic of a concept - end is the same but the means are very different
                  Next level of specialization (Raster, Vector, etc) is valuable, as are the specializations within that (Hardware, Software, Curses, etc)
            The actual problem is conversion between the different types of framebuffer
                  Ex.
                        ColorRGB<f32> -> ColorRGB<u8>
                              Simple map(Into::into) across framebuffer data
                        ((ColorIndex, i64), (char, i64)) -> (ColorIndex, char)
                              Fold with z-buffer predicate
                        (ColorIndex, char) -> (chtype, chtype) -> chtype
                              Fold with chtype conversion and logical OR
                        Vector -> Raster
                              Reinterpret vector line list as line primitives, process with raster renderer
                  Can this be made into a generic adapter system?

      Curses renderer doesn't fit into the Renderer / Framebuffer pattern yet
            Elements:
                  Merge color and char framebuffers into pancurses color index + char (chtype)
                  Render to curses

      Notes:
            Renderer Trait - Something that reads data from the ECS (so all Renderers must be Systems) and renders it into a framebuffer
                  RasterRenderer Trait? - Renderer that operates on RasterFramebuffers
                        SoftwareRasterRenderer Trait
                              ColorRenderer
                              StringRenderer
                        CursesRasterRenderer?
                  VectorRenderer Trait? - Renderer that operates on a VectorFramebuffers
            Framebuffer Trait - Data storage that can be written to by a Renderer
                  RasterFramebuffer Trait - 2D grid data storage
                        SoftwareRasterFramebuffer - 2D grid data stored in RAM
                        CursesWindow - 2D grid data stored in Curses, interface to a curses window handle
                        HardwareRasterFramebuffer? - 2D grid data stored in VRAM, interface to a graphics library framebuffer handle
                  VectorFramebuffer Trait? - Line list data storage
                        SoftwareVectorFramebuffer? - Line list data stored in RAM

            Existing color case can be classified as a Software / Raster / ColorRGBF framebuffer
            Existing char case can be classified as a Software / Raster / char framebuffer
            Existing curses case can be classified as a Hardware / Raster / (ColorRGBF, char) framebuffer
                  Probably not actually ColorRGBF, since it uses an indexed palette - room for more generalization here
            Other examples:
                  Hardware / Raster / ColorRGBF
                  Hardware / Raster / ColorRGB8
            Raster framebuffer is the most common case
            Categories:
                  Forward / Deferred
                  Software / Hardware
                  Raster / Vector
                  ColorRGBF / ColorRGB8
            Vector framebuffer is an example of an exotic case
                  List of position + color vertices describing lines or line strips
                  Needs to be rasterized for display
                        Some kind of chaining mechanism is necessary
                        Should feed into a rasterizing renderer as line primitives
            Refactor existing Renderer behavior into a RasterRenderer trait
                  Should encapsulate grid iteration logic
                        How do position and size params factor in here - inherent to raster renderer?
                              Currently yes, but the more general implementation is polygonal meshes + vertex shader
            Modify StringRenderer to use a SoftwareShader that takes string input and outputs characters
                  Should strings instead be a case of an exotic framebuffer?
                  List of position + string vertices
                        Needs to feed into a rasterizing renderer that takes string primitives and outputs chars

TODO: Fix type name sanitization stripping K from Foo<K, V>

TODO: Can anchors/margins be refactored into separate systems?
      More specifically, can margins be generalized?
            Would need somewhere to store final position / size data
            GlobalPosition already does this, but is in and of itself more general
            Preferable to keep things unified if possible - too much overlap between GlobalPosition and MarginPosition
            Could handle in renderer?

TODO: Max limit for list scroll offset
TODO: Scrollbar for lists

TODO: Vertical scrolling for HSV shader

TODO: Vertically-split 2x multisampling for each curses cell
      Will need to make UV a first-class parameter derived from position/size in the software renderer
      Parametrize at SoftwareRenderer construction as Option<Vec<(f32, f32)>> for a custom kernel, default to single-sample if None
      Invoke multiple times with offsets from kernel, average result
      Refer to this as AA, not MSAA - while accurate in the literal sense of multi-sampled AA, the GPU version only applies to edges

TODO: Type-level color/framebuffer/renderer support for HSV, palette index

TODO: Shader chaining - take an Option<fn(ShaderInput)> to allow for combination (ex. a wire rect that has a color effect)

TODO: Cleanup pass for distinction between CursesInput / CursesEvent

TODO: Split IntRangeComponent into i64 and Range<i64>
      Would this be better codified as ListRange and ListIndex?
      Could do away with range altogether and draw directly from list size

TODO: Filtering for debug components
      (Would this be better expressed as a sort + color highlight?)
      Entities
        If a component is selected, filter out entities that don't have it
        If component data is selected, filter out other entities
        If a system is selected, filter out entities that don't have components that it processes (pending system dependency setup)
      Scene tree
        Use the same rules as entities
      Components
        If an entity is selected, filter out components that don't have a data entry for it
        If component data is selected, filter out other components
        If a system is selected, filter out components that it doesn't process (pending system dependency setup)
      Component data
        If an entity is selected, filter out data from other entities
        If a component is selected, filter out data from other components
        If a system is selected, filter out data from components that system doesn't process (pending system dependency setup)

TODO: Profiler window
      Will need a custom shader input struct to draw graphs
            Can this be done via generics?
            Or is it better to use generic ShaderInputComponent<T> storage looked up by the shader?
                  Wouldn't work directly for GPU, but could be wrapped by the appropriate renderer
            Could setup shader-specific systems and dataflow for more complex functionality
                  Easy to keep general, can define your own pipeline

TODO: Component data inspector
      How would this work?
      Seems like it would be necessary to introduce some sort of property interface for get/set of specific fields

TODO: Clipping rects for UI controls
TODO: Refactor list system to only update when hover, selection, list item count or contents have changed

TODO: Register entity fetches and associated logic at System registration time
      Allows for runtime lookup optimization

TODO: Custom component storage registration
    SparseVecMap - Very common components (ex. position)
    DenseVecMap - Somewhat common components (ex. mesh, physics body)
    HashMap - Rare components (ex. framebuffer, texture, audio)

    How to encode rarity? Custom entity fetches could be used as a heuristic
    
    How should these categories interact with Store's default type sizing predicate?
        Rarity should probably take precedence, since memory wastage scales linearly with entity count for SparseVecMap